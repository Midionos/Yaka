/*
 *
 *       Auteur: La team des arracheurs de dents
 *
 * 	cr�ation : 15 f�vrier 2013
 *
 *     nature : projet etudiant
 *
 */
options
{
  JDK_VERSION = "1.5";
}

PARSER_BEGIN(Yaka)
public class Yaka {
  public static Declaration declaration;
  public static TabIdent tabIdent;
  public static Expression expression;
  public static YVM yvm;
  public static EntreeSortie entreeSortie;
  
  public static void initVariables() {
      expression = new Expression();
  	  declaration = new Declaration();
  	  yvm = new YVM();
      Yaka.tabIdent = new TabIdent(10);
      entreeSortie = new EntreeSortie();      
  }
  
  public static void main(String args []) {
    java.io.InputStream input;
    if (args.length == 1) {
      System.out.print(args [args.length - 1] + ": ");
      try {
        input = new java.io.FileInputStream(args [args.length - 1] + ".yaka");
      } catch (java.io.FileNotFoundException e) {
        System.out.println("Fichier introuvable.");
        return;
      }
    }
    else if (args.length == 0) {
      System.out.println("Lecture sur l'entree standard...");
      input = System.in;
    } else {
      System.out.println("Usage: java Gram [fichier]");
      return;
    }
    try {
      new Yaka(input);
	  expression = new Expression();
  	  declaration = new Declaration();
  	  yvm = new YVM();
      Yaka.tabIdent = new TabIdent(10);
      Yaka.analyse();
      System.out.println("analyse syntaxique reussie!");
      System.out.println(Yaka.expression.getResult());
    } catch (ParseException e) {
      String msg = e.getMessage();
      msg = msg.substring(0, msg.indexOf("\n"));
      System.out.println("Erreur de syntaxe : " + msg);
    }
  }
}

PARSER_END(Yaka)

/***************************************/
/********** TOKEN DEFINITIONS **********/
/***************************************/
TOKEN_MGR_DECLS :
{
  public static String identLu, chaineLue;

  public static int entierLu;
}

/*** Skip whitespace and comments ***/
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "(*" : IN_COMMENT
}

< IN_COMMENT >
MORE :
{
  < ~[ ] >
}

< IN_COMMENT >
SKIP :
{
  < "*)" >
  {
    SwitchTo(DEFAULT);
  }
}

/* Mots r�serv�s*/
TOKEN :
{
  < BOOLEEN : "BOOLEEN" >
| < VAR : "VAR" >
| < FAIRE : "FAIRE" >
| < SINON : "SINON" >
| < POUR : "POUR" >
| < SI : "SI" >
| < FSI : "FSI" >
| < ENTIER : "ENTIER" >
| < RETOURNE : "RETOURNE" >
| < VRAI : "VRAI" >
| < TANTQUE : "TANTQUE" >
| < CONST : "CONST" >
| < FAUX : "FAUX" >
| < FAIT : "FAIT" >
| < OU : "OU" >
| < ET : "ET" >
| < NON : "NON" >
| < FONCTION : "FONCTION" >
| < FFONCTION : "FFONCTION" >
| < PROGRAMME : "PROGRAMME" >
| < FPROGRAMME : "FPROGRAMME" >
| < PRINCIPAL : "PRINCIPAL" >
| < FPRINCIPAL : "FPRINCIPAL" >
| < ALORS : "ALORS" >
| < ECRIRE : "ECRIRE" >
| < LIRE : "LIRE" >
| < ALALIGNE : "ALALIGNE" >
}

/*** unites de base nombres, idents,  strings ***/
TOKEN :
{
  < #chiffre : [ "0"-"9" ] >
| < entier : (< chiffre >)+ >
  {
    entierLu = Integer.parseInt(image.toString());
  }
| < #lettre : [ "A"-"Z", "a"-"z" ] >
| < ident :
    < lettre >
    (
      < lettre >
    | < chiffre >
    )* >
  {
    identLu = image.toString();
  }
| < chaine :
    "\"" (~[ "\"" ])* "\""
  | "'" (~[ "'" ])* "'" >
  {
    chaineLue = image.toString();
  }
}

/**************************************/
/********debut de la grammaire ********/
/**************************************/

/******** Main ********/
void analyse() : {}	{
  < PROGRAMME > < ident > 
  bloc() 
  < FPROGRAMME >
}

void bloc() : {} {
  (declConst())*
  (declVar())*
  suiteInstr()
}

/******** Definitions ********/
void declConst() : {} {
  < CONST > defConst()
  ("," defConst())*
  ";"
}

void defConst() : {} {
  < ident > 	{declaration.defConst(YakaTokenManager.identLu);}
  "=" valConst()
}

void valConst() : {} {
  < entier > 	{declaration.valConst(Type.INT, YakaTokenManager.entierLu);}
| < ident > 	{declaration.valConstRef(YakaTokenManager.identLu);}
| < VRAI > 		{declaration.valConst(Type.BOOL, Constante.VRAI);}
| < FAUX > 		{declaration.valConst(Type.BOOL, Constante.FAUX);}
}

void declVar() : {} {
  < VAR > type() 
  < ident > {declaration.defVar(YakaTokenManager.identLu);}
  ("," < ident > {declaration.defVar(YakaTokenManager.identLu);} )* ";"
}

void type() : {} {
  < ENTIER > {declaration.declVar(Type.INT);}
| < BOOLEEN > {declaration.declVar(Type.BOOL);}
}

	
/******** Expression ********/
void expression() : {} {
  simpleExpr()
  (opRel() simpleExpr())?
}

void simpleExpr() : {} {
  terme()
  (opAdd() terme() {Yaka.expression.compute();} )*
}

void terme() : {} {
  facteur()
  (opMul() facteur() {Yaka.expression.compute();} )*
}

void facteur() : {} {
  primaire()
| opNeg() 		{Yaka.expression.invert();}
  primaire() 	{Yaka.expression.compute();}
}

void primaire() : {} {
  valeur()
| "(" expression() ")"
}

void valeur() : {} {
  < entier > 	{Yaka.expression.pushInteger(YakaTokenManager.entierLu);}
| < ident > 	{Yaka.expression.pushIdent(YakaTokenManager.identLu);}
| < VRAI > 		{Yaka.expression.pushBoolean(Constante.TRUE);}
| < FAUX > 		{Yaka.expression.pushBoolean(Constante.FALSE);}
}

void opRel() : {} {
  "=" 	{Yaka.expression.pushOperator(Operator.EQUAL);}
| "<>" 	{Yaka.expression.pushOperator(Operator.DIFF);}
| "<" 	{Yaka.expression.pushOperator(Operator.LT);}
| "<=" 	{Yaka.expression.pushOperator(Operator.LTE);}
| ">" 	{Yaka.expression.pushOperator(Operator.GT);}
| ">=" 	{Yaka.expression.pushOperator(Operator.GTE);}
}

void opAdd() : {} {
  "+" 		{Yaka.expression.pushOperator(Operator.ADD);}
| "-" 		{Yaka.expression.pushOperator(Operator.SUB);}
| < OU > 	{Yaka.expression.pushOperator(Operator.OR);}
}

void opMul() : {} {
  "*" 		{Yaka.expression.pushOperator(Operator.MUL);}
| "/" 		{Yaka.expression.pushOperator(Operator.DIV);}
| < ET > 	{Yaka.expression.pushOperator(Operator.AND);}
}

void opNeg() : {} {
  "-" 		{Yaka.expression.pushOperator(Operator.NEG);}
| < NON > 	{Yaka.expression.pushOperator(Operator.NOT);}
}


/******** Affectation ********/
void suiteInstr() : {} {	instruction()	(	  ";"
	  (instruction())?	)*
}

void instruction() : {} {
  affectation() | lecture() | ecriture()}

void affectation() : {} {  < ident > {Yaka.expression.setAffectation(YakaTokenManager.identLu);}
   "="
   expression() {Yaka.expression.affectation();}}

/******** Reading ********/
void lecture() : {} {
  < LIRE > "(" < ident > ")" {Yaka.entreeSortie.lire(YakaTokenManager.identLu);}}
/******** Writing ********/
void ecriture() : {} {
  < ECRIRE > "(" { expression() {Yaka.entreeSortie.ecrireEnt();} 
  | < chaine > {Yaka.entreeSortie.ecrireChaine(YakaTokenManager.identLu);} } ")" 
  | < ALALIGNE > {Yaka.entreeSortie.aLaLigne();}}







/******** Iteration ********/


/******** Conditional ********/


/******** Functions ********/
